(window.webpackJsonp=window.webpackJsonp||[]).push([[80],{334:function(e,o,r){"use strict";r.r(o);var t=r(2),n=Object(t.a)({},(function(){var e=this,o=e.$createElement,r=e._self._c||o;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"_004-commonjs和es6"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_004-commonjs和es6","aria-hidden":"true"}},[e._v("#")]),e._v(" 004-CommonJS和ES6")]),e._v(" "),r("blockquote",[r("p",[e._v("转载自："),r("a",{attrs:{href:"https://juejin.im/post/5e3985396fb9a07cde64c489#heading-6",target:"_blank",rel:"noopener noreferrer"}},[e._v("你可能不知道的 JavaScript 模块化野史"),r("OutboundLink")],1)])]),e._v(" "),r("h1",{attrs:{id:"es-module"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#es-module","aria-hidden":"true"}},[e._v("#")]),e._v(" ES Module")]),e._v(" "),r("p",[e._v("在2015 年 6 月， ECMAScript6 标准正式发布，其中的 ES 模块化规范的提出目标是整合 CommonJS、AMD 等已有模块方案，在语言标准层面实现模块化，成为浏览器和服务器通用的模块解决方案。")]),e._v(" "),r("p",[e._v("模块功能由 export 和 import 两个命令完成。export 对外输出模块，import 用于引入模块。"),r("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/import",target:"_blank",rel:"noopener noreferrer"}},[e._v("import 更多用法"),r("OutboundLink")],1),e._v(", "),r("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/export",target:"_blank",rel:"noopener noreferrer"}},[e._v("export 更多用法"),r("OutboundLink")],1),e._v("。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// 导入单个接口\nimport {myExport} from '/modules/my-module.js';\n// 导入多个接口\nimport {foo, bar} from '/modules/my-module.js';\n\n// 导出早前定义的函数\nexport { myFunction }; \n\n// 导出常量\nexport const foo = Math.sqrt(2);\n\n复制代码\n")])])]),r("p",[e._v("ES Module 与 CommonJS 及 Loaders 等方案的区别主要在以下方面：")]),e._v(" "),r("ul",[r("li",[e._v("声明式而非命令式，或者说 "),r("code",[e._v("import")]),e._v(" 是声明语句 Declaration 而非表达式 Statement，在 ES Module 中无法使用 "),r("code",[e._v("import")]),e._v(" 声明带变量的依赖、或者动态引入依赖：")]),e._v(" "),r("li",[e._v("CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。")]),e._v(" "),r("li",[r("code",[e._v("import")]),e._v(" 是预先解析、预先加载的，不像 RequireJS 等是执行到点了再发一个请求")])]),e._v(" "),r("p",[e._v("对务实主义的 Node.js 开发者来说，这些区别都让 npm 所营造出来的海量社区代码陷入一种尴尬的境地，无论是升级还是兼容都需要大量的工作。对此，David Herman 撰文解释，"),r("a",{attrs:{href:"http://calculist.org/blog/2012/06/29/static-module-resolution/",target:"_blank",rel:"noopener noreferrer"}},[e._v("ES Module 所带来的好处远大于不便"),r("OutboundLink")],1),e._v("：")]),e._v(" "),r("ul",[r("li",[r("strong",[e._v("静态 "),r("code",[e._v("import")]),e._v(" 能确保被编译成变量引用")]),e._v("，这些引用在当前执行环境运行时能被解析器（通过 JIT 编译 "),r("a",{attrs:{href:"http://blog.cdleary.com/2010/09/picing-on-javascript-for-fun-and-profit/",target:"_blank",rel:"noopener noreferrer"}},[e._v("polymorphic inline cache"),r("OutboundLink")],1),e._v("）优化，执行更有效率")]),e._v(" "),r("li",[r("strong",[e._v("静态 export 能让变量检测更准确")]),e._v("，在 JSHint、ESLint 等代码检测工具中，变量是否定义是个非常受欢迎的功能，而静态 "),r("code",[e._v("export")]),e._v(" 能让这一检测更具准确性")]),e._v(" "),r("li",[r("strong",[e._v("更完备的循环依赖处理")]),e._v("，在 Node.js 等已有的 CommonJS 实现中，循环依赖是通过传递未完成的 "),r("code",[e._v("exports")]),e._v(" 对象解决的，对于直接引用 "),r("code",[e._v("exports.foo")]),e._v(" 或者父模块覆盖 "),r("code",[e._v("module.exports")]),e._v(" 的情况，传统方式无从解决，而因为 ES Module 传递的是引用，便不会有这些问题")])]),e._v(" "),r("p",[e._v("其他还有对未来可能新增的标准（宏、类型系统等）更兼容等。")]),e._v(" "),r("h2",{attrs:{id:"es-module-in-browser"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#es-module-in-browser","aria-hidden":"true"}},[e._v("#")]),e._v(" ES Module in Browser")]),e._v(" "),r("p",[e._v("在 ES Module 标准出来之前，尽管社区实现的 Loader 一箩筐，但浏览器自身一直没有选定模块方案，支持 ES Module 对浏览器来说还是比较少顾虑的。")]),e._v(" "),r("p",[e._v("由于 ES Module 的执行环境和普通脚本不同，浏览器选择增加 "),r("code",[e._v("，只有")]),e._v(" 中的脚本（和 "),r("code",[e._v("import")]),e._v(" 进来的脚本）才是 "),r("code",[e._v("module")]),e._v(" 模式。也只有 "),r("code",[e._v("module")]),e._v(" 模式执行的脚本，才可以声明 "),r("code",[e._v("import")]),e._v(" 。也就是说，下面这种代码是不行的：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('<script>\nimport foo from "./foo.js"\n<\/script>\n\n<script type="javascript">\nimport bar from "./bar.js"\n<\/script>\n复制代码\n')])])]),r("p",[e._v("目前，几大常青浏览器都"),r("a",{attrs:{href:"https://caniuse.com/#search=import",target:"_blank",rel:"noopener noreferrer"}},[e._v("已支持 ES Module"),r("OutboundLink")],1),e._v("。最后一个支持的是 Firefox，2018 年 5 月 8 日发布的 Firefox 60 正式支持 ES Module。")]),e._v(" "),r("p",[e._v("此外，考虑到向后兼容，浏览器还增加 "),r("code",[e._v("标签。开发者可以使用")]),e._v(" 标签兼容不支持 ES Module 的浏览器：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('// 在浏览器中，import 语句只能在声明了 type="module" 的 script 的标签中使用。\n<script type="module" src="./app.js"><\/script>\n// 在 script 标签中使用 nomodule 属性，可以确保向后兼容。\n<script nomodule src="./app.bundle.js"><\/script>\n复制代码\n')])])]),r("h2",{attrs:{id:"es-module-in-node-js"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#es-module-in-node-js","aria-hidden":"true"}},[e._v("#")]),e._v(" ES Module in Node.js")]),e._v(" "),r("p",[e._v("但在 Node.js 这边，ES Module 遭遇的声音要大很多。前 Node.js 领导者 Isaacs Schlutuer 甚至认为 ES Module 太过阳春白雪且不考虑实际情况，毫无价值（"),r("a",{attrs:{href:"http://blog.izs.me/post/25906678790/on-es-6-modules",target:"_blank",rel:"noopener noreferrer"}},[e._v("adds nothing"),r("OutboundLink")],1),e._v("）。")]),e._v(" "),r("p",[e._v("首先纠结的是如何支持 "),r("code",[e._v("module")]),e._v(" 执行模式，是自动检测，还是 "),r("code",[e._v("'use module'")]),e._v(" ，还是在 "),r("code",[e._v("package.json")]),e._v(" 里增加 "),r("code",[e._v("module")]),e._v(" 属性作为专门的入口，还是干脆增加一个新的扩展名？")]),e._v(" "),r("p",[e._v("最终 Node.js 选择增加新的扩展名 "),r("code",[e._v(".mjs")]),e._v(" ：")]),e._v(" "),r("ul",[r("li",[e._v("在 "),r("code",[e._v(".mjs")]),e._v(" 中可以自如使用 "),r("code",[e._v("import")]),e._v(" 和 "),r("code",[e._v("export")])]),e._v(" "),r("li",[e._v("在 "),r("code",[e._v(".mjs")]),e._v(" 中不可以使用 "),r("code",[e._v("require")])]),e._v(" "),r("li",[e._v("在 "),r("code",[e._v(".js")]),e._v(" 中只能使用 "),r("code",[e._v("require")])]),e._v(" "),r("li",[e._v("在 "),r("code",[e._v(".js")]),e._v(" 中不可以使用 "),r("code",[e._v("import")]),e._v(" 和 "),r("code",[e._v("export")])])]),e._v(" "),r("p",[e._v("也就是两套模块系统完全独立。此外，依赖查找方式也有变化，原本 "),r("code",[e._v("require.extensions")]),e._v(" 是：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("{ '.js': [Function],\n  '.json': [Function],\n  '.node': [Function] }\n复制代码\n")])])]),r("p",[e._v("如今（需要开启 "),r("code",[e._v("--experimental-modules")]),e._v(" 选项）则是：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("{ '.js': [Function],\n  '.json': [Function],\n  '.node': [Function],\n  '.mjs': [Function] }\n复制代码\n")])])]),r("p",[e._v("但两套独立的模块系统也导致第二个纠结的方面，模块系统彼此之间如何互通？对浏览器来说这不是问题，但对 Node.js 来说，npm 中海量的 CommonJS 模块是它不得不考虑的。")]),e._v(" "),r("p",[e._v("最终确定的方案倒也简单，在 "),r("code",[e._v(".mjs")]),e._v(" 里，开发者可以 "),r("code",[e._v("import")]),e._v(" CommonJS（虽然只能 "),r("code",[e._v("import default")]),e._v("）：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("import 'fs' from 'fs'\nimport { readFile } from 'fs'\nimport foo from './foo'\n// etc.\n复制代码\n")])])]),r("p",[e._v("在 "),r("code",[e._v(".js")]),e._v(" 里，开发者自然不能 "),r("code",[e._v("import")]),e._v(" ES Module，但他们可以 "),r("code",[e._v("import()")]),e._v(" ：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("import('./foo').then(foo => {\n  // use foo\n})\n\nasync function() {\n  const bar = await import('./bar')\n  // use bar\n}()\n复制代码\n")])])]),r("p",[e._v("注意，和浏览器以引入方式判断运行模式不同，Node.js 中脚本的运行模式是和扩展名绑定的。也就是说，依赖的查找方式会有所不同：")]),e._v(" "),r("ul",[r("li",[e._v("在 "),r("code",[e._v(".js")]),e._v(" 中 "),r("code",[e._v("require('./foo')")]),e._v(" 找的是 "),r("code",[e._v("./foo.js")]),e._v(" 或者 "),r("code",[e._v("./foo/index.js")])]),e._v(" "),r("li",[e._v("在 "),r("code",[e._v(".mjs")]),e._v(" 中 "),r("code",[e._v("import './bar'")]),e._v(" 找的是 "),r("code",[e._v("./bar.mjs")]),e._v(" 或者 "),r("code",[e._v("./bar/index.mjs")])])]),e._v(" "),r("p",[e._v("善用这些特性，我们现在就可以将已有的 npm 模块升级成 ES Module，并且仍然支持 CommonJS 方式。")]),e._v(" "),r("h2",{attrs:{id:"dynamic-import"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#dynamic-import","aria-hidden":"true"}},[e._v("#")]),e._v(" Dynamic Import")]),e._v(" "),r("p",[e._v("静态型的 "),r("code",[e._v("import")]),e._v(" 是初始化加载依赖项的最优选择，使用静态 "),r("code",[e._v("import")]),e._v(" 更容易从代码静态分析工具和 "),r("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Glossary/Tree_shaking",target:"_blank",rel:"noopener noreferrer"}},[e._v("tree shaking"),r("OutboundLink")],1),e._v(" 中受益。但当希望按照一定的条件或者按需加载模块的时候，需要动态引入依赖，例如：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("if (process.env.NODE_ENV !== 'production') {\n  require('./cjs/react.development.js')\n} else {\n  require('./cjs/react.production.js')\n}\n\nif (process.env.BROWSER) {\n  require('./browser.js')\n}\n复制代码\n")])])]),r("p",[e._v("为此，Domenic Denicola 起草 "),r("code",[e._v("import()")]),e._v(" "),r("a",{attrs:{href:"http://2ality.com/2017/01/import-operator.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("标准"),r("OutboundLink")],1),r("a",{attrs:{href:"https://github.com/tc39/proposal-dynamic-import",target:"_blank",rel:"noopener noreferrer"}},[e._v("提案"),r("OutboundLink")],1),e._v("。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('//这是一个处于第三阶段的提案。\nvar promise = import("module-name");\n复制代码\n')])])]),r("p",[e._v("除了可以用来处理动态依赖，HTML 中的 script 标签不需要声明 "),r("code",[e._v('type="module"')]),e._v(" 。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("<script>\nimport('./foo.js').then(foo => {\n  // use foo\n})\n<\/script>\n复制代码\n")])])]),r("p",[e._v("在 Node.js 中（"),r("code",[e._v(".js")]),e._v(" 文件）还可以使用 import() 引入使用 import 的 ES Module ：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("import('./foo.mjs').then(foo => {\n  // use foo\n})\n复制代码\n")])])]),r("p",[e._v("使用 ES Module 编写浏览器、Node.js 通用的 JavaScript 模块化代码已经完全可行，我们还需要编译或者打包工具吗？")])])}),[],!1,null,null,null);o.default=n.exports}}]);