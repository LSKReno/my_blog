(window.webpackJsonp=window.webpackJsonp||[]).push([[103],{358:function(e,t,a){"use strict";a.r(t);var p=a(2),v=Object(p.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"_013-如何理解-tcp-的-keep-alive？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_013-如何理解-tcp-的-keep-alive？","aria-hidden":"true"}},[e._v("#")]),e._v(" 013-如何理解 TCP 的 keep-alive？")]),e._v(" "),a("p",[e._v("大家都听说过 http 的keep-alive, 不过 TCP 层面也是有keep-alive机制，而且跟应用层不太一样。")]),e._v(" "),a("p",[e._v("试想一个场景，当有一方因为网络故障或者宕机导致连接失效，由于 TCP 并不是一个轮询的协议，在下一个数据包到达之前，对端对连接失效的情况是一无所知的。")]),e._v(" "),a("p",[e._v("这个时候就出现了 keep-alive, 它的作用就是探测对端的连接有没有失效。")]),e._v(" "),a("p",[e._v("在 Linux 下，可以这样查看相关的配置:")]),e._v(" "),a("div",{staticClass:"language-text extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("sudo sysctl -a | grep keepalive\n\n// 每隔 7200 s 检测一次\nnet.ipv4.tcp_keepalive_time = 7200\n// 一次最多重传 9 个包\nnet.ipv4.tcp_keepalive_probes = 9\n// 每个包的间隔重传间隔 75 s\nnet.ipv4.tcp_keepalive_intvl = 75\n")])])]),a("p",[e._v("不过，现状是大部分的应用并没有默认开启 TCP 的keep-alive选项，为什么？")]),e._v(" "),a("p",[e._v("站在应用的角度: - 7200s 也就是两个小时检测一次，时间太长 - 时间再短一些，也难以体现其设计的初衷, 即检测长时间的死连接")]),e._v(" "),a("p",[e._v("因此是一个比较尴尬的设计。")])])}),[],!1,null,null,null);t.default=v.exports}}]);