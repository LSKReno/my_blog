(window.webpackJsonp=window.webpackJsonp||[]).push([[91],{345:function(v,_,t){"use strict";t.r(_);var s=t(2),e=Object(s.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"基础概念扫盲"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基础概念扫盲","aria-hidden":"true"}},[v._v("#")]),v._v(" 基础概念扫盲")]),v._v(" "),t("p",[v._v("先扫盲：")]),v._v(" "),t("p",[v._v("frame对应mac，packet对应ip，datagram对应udp，segment对应tcp，message对应app。")]),v._v(" "),t("p",[v._v("上问题：")]),v._v(" "),t("ol",[t("li",[v._v("请画出三次握手和四次挥手的示意图")]),v._v(" "),t("li",[v._v("为什么连接的时候是三次握手？")]),v._v(" "),t("li",[v._v("什么是半连接队列？")]),v._v(" "),t("li",[v._v("ISN(Initial Sequence Number)是固定的吗？")]),v._v(" "),t("li",[v._v("三次握手过程中可以携带数据吗？")]),v._v(" "),t("li",[v._v("如果第三次握手丢失了，客户端服务端会如何处理？")]),v._v(" "),t("li",[v._v("SYN攻击是什么？")]),v._v(" "),t("li",[v._v("挥手为什么需要四次？")]),v._v(" "),t("li",[v._v("四次挥手释放连接时，等待2MSL的意义?")])]),v._v(" "),t("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://lskreno.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/1.jpg"}}),v._v(" "),t("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://lskreno.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/2.jpg"}}),v._v(" "),t("p",[v._v("这篇文章的思维导图:")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://pic3.zhimg.com/80/v2-dbbdb2ba824a121f18a66059ac0b5ac2_720w.jpg",alt:"img"}})]),v._v(" "),t("p",[v._v("TCP 作为传输层的协议，是一个软件工程师素养的体现，也是面试中经常被问到的知识点。在此，我将 TCP 核心的一些问题梳理了一下，希望能帮到各位。")]),v._v(" "),t("p",[v._v("随着对网络的理解深入，明白TCP报文是交由IP网络来负责运输，IP网络并不能保证TCP报文到达目的地，既然IP网络是指望不上了，那TCP就自力更生吧，TCP必须依赖自身的努力来保证数据传输的可靠。")]),v._v(" "),t("p",[v._v("TCP看似复杂，其实可以归纳为以下5种报文：")]),v._v(" "),t("p",[v._v("（1）SYN")]),v._v(" "),t("p",[v._v("（2）Data（唯一携带用户数据）")]),v._v(" "),t("p",[v._v("（3）FIN")]),v._v(" "),t("p",[v._v("（4）Reset")]),v._v(" "),t("p",[v._v("（5）ACK")]),v._v(" "),t("p",[v._v("其中1、2、3分别为"),t("strong",[v._v("建立连接、数据传输、断开连接")]),v._v("，这"),t("strong",[v._v("三种报文对方接收到一定要ACK确认")]),v._v("，为何要确认，因为这就是可靠传输的依赖的机制。如果对方在"),t("strong",[v._v("超时时间内不确认，发送方会一直重传")]),v._v("，直到对方确认为止、"),t("strong",[v._v("或到达重传上限次数而Reset连接。")])]),v._v(" "),t("p",[v._v("4、5 为"),t("strong",[v._v("重置连接报文、确认ACK报文")]),v._v("，这两种报文对方接收到要ACK确认吧？不需要！自然发送方也不会重传这2种类型的报文。")]),v._v(" "),t("p",[t("strong",[v._v("为何Reset报文不需要ACK确认?")])]),v._v(" "),t("p",[v._v("因为发送Reset报文的一端，在发送完这个报文之后，和该TCP Session有关的内存结构体瞬间全部释放，无论对方收到或没有收到，关系并不大。")]),v._v(" "),t("p",[v._v("如果对方收到Reset报文，也会释放该TCP Session 的相关内存结构体。")]),v._v(" "),t("p",[v._v("如果对方没有收到Reset 报文，可能会继续发送让接收方弹射出Reset报文的报文，到最后对方一样会收到Reset 报文，并最终释放内存。")]),v._v(" "),t("p",[t("strong",[v._v("为何ACK报文不需要ACK确认?")])]),v._v(" "),t("p",[v._v("这里的ACK报文，是指没有携带任何数据的裸ACK报文，对方收到这样的ACK报文，自然也不需要ACK。否则，对方为了ACK己方的ACK，那己方收到对方的ACK，也要ACK对方的ACK，这就是一个死循环，永无止息。")]),v._v(" "),t("p",[v._v("所以为了避免这个死循环，一律不允许ACK对方的裸ACK报文。")]),v._v(" "),t("p",[v._v("有同学会说，按照这么说，TCP连接应该是四次消息交互啊。")]),v._v(" "),t("p",[t("strong",[v._v("1.A 发送SYN 报文给B，这是第一次报文交互。")])]),v._v(" "),t("p",[t("strong",[v._v("2. B发送ACK确认A的SYN报文，这是第二次报文交互")])]),v._v(" "),t("p",[t("strong",[v._v("3. B发送自己的SYN报文给A，这是第三次报文交互")])]),v._v(" "),t("p",[t("strong",[v._v("4. A需要ACK确认B的SYN报文，这是第四次报文交互")])]),v._v(" "),t("p",[v._v("以上的演绎没有问题，但是报文2、3为何要分开发送呢？增加了延迟不说，同时还白白浪费了网络的带宽，完全可以将报文2、3合并起来，不就是在报文2的ACK状态位的位置置“1”就结了吗？")]),v._v(" "),t("p",[v._v("这就是三次消息交互的由来！")])])}),[],!1,null,null,null);_.default=e.exports}}]);