(window.webpackJsonp=window.webpackJsonp||[]).push([[93],{347:function(v,_,e){"use strict";e.r(_);var t=e(2),s=Object(t.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h1",{attrs:{id:"_002-说说-tcp-三次握手的过程？为什么是三次而不是两次、四次？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_002-说说-tcp-三次握手的过程？为什么是三次而不是两次、四次？","aria-hidden":"true"}},[v._v("#")]),v._v(" 002: 说说 TCP 三次握手的过程？为什么是三次而不是两次、四次？")]),v._v(" "),e("h3",{attrs:{id:"恋爱模拟"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#恋爱模拟","aria-hidden":"true"}},[v._v("#")]),v._v(" 恋爱模拟")]),v._v(" "),e("p",[v._v("以谈恋爱为例，两个人能够在一起最重要的事情是首先确认各自"),e("strong",[v._v("爱")]),v._v("和"),e("strong",[v._v("被爱")]),v._v("的能力。接下来我们以此来模拟三次握手的过程。")]),v._v(" "),e("p",[v._v("第一次:")]),v._v(" "),e("p",[v._v("男: "),e("strong",[v._v("我爱你。")])]),v._v(" "),e("p",[v._v("女方收到。")]),v._v(" "),e("p",[v._v("由此证明男方拥有爱的能力。")]),v._v(" "),e("p",[v._v("第二次:")]),v._v(" "),e("p",[v._v("女: "),e("strong",[v._v("我收到了你的爱，我也爱你。")])]),v._v(" "),e("p",[v._v("男方收到。")]),v._v(" "),e("p",[v._v("OK，现在的情况说明，女方拥有爱和被爱的能力。")]),v._v(" "),e("p",[v._v("第三次:")]),v._v(" "),e("p",[v._v("男: "),e("strong",[v._v("我收到了你的爱。")])]),v._v(" "),e("p",[v._v("女方收到。")]),v._v(" "),e("p",[v._v("现在能够保证男方具备被爱的能力。")]),v._v(" "),e("p",[v._v("由此完整地确认了双方爱和被爱的能力，两人开始一段甜蜜的爱情。")]),v._v(" "),e("h3",{attrs:{id:"真实握手"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#真实握手","aria-hidden":"true"}},[v._v("#")]),v._v(" 真实握手")]),v._v(" "),e("p",[v._v("当然刚刚那段属于扯淡，不代表本人价值观，目的是让大家理解整个握手过程的意义，因为两个过程非常相似。对应到 TCP 的三次握手，也是需要确认双方的两样能力: 发送的能力和接收的能力。于是便会有下面的三次握手的过程:")]),v._v(" "),e("img",{staticStyle:{zoom:"80%"},attrs:{src:"https://pic3.zhimg.com/80/v2-859c73d767b7211e7f094ecaa4938fde_720w.jpg",alt:"img"}}),v._v(" "),e("p",[v._v("从最开始双方都处于CLOSED状态。然后服务端开始监听某个端口，进入了LISTEN状态。")]),v._v(" "),e("p",[v._v("然后客户端主动发起连接，发送 SYN , 自己变成了SYN-SENT状态。")]),v._v(" "),e("p",[v._v("服务端接收到，返回SYN和ACK(对应客户端发来的SYN)，自己变成了SYN-REVD。")]),v._v(" "),e("p",[v._v("之后客户端再发送ACK给服务端，自己变成了ESTABLISHED状态；服务端收到ACK之后，也变成了ESTABLISHED状态。")]),v._v(" "),e("p",[v._v("另外需要提醒你注意的是，从图中可以看出，SYN 是需要消耗一个序列号的，下次发送对应的 ACK 序列号要加1，为什么呢？只需要记住一个规则:")]),v._v(" "),e("blockquote",[e("p",[v._v("凡是需要对端确认的，一定消耗TCP报文的序列号。")])]),v._v(" "),e("p",[v._v("SYN 需要对端的确认， 而 ACK 并不需要，因此 SYN 消耗一个序列号而 ACK 不需要。")]),v._v(" "),e("p",[v._v("TCP作为一种可靠传输控制协议，其"),e("strong",[v._v("核心思想")]),v._v("：既要保证数据可靠传输，又要提高传输的效率，而用"),e("strong",[v._v("三次恰恰可以满足以上两方面的需求！")])]),v._v(" "),e("p",[e("strong",[v._v("TCP可靠传输的精髓："),e("strong",[v._v("TCP连接的一方A，由操作系统动态随机选取一个")]),v._v("32位长的序列号（Initial Sequence Number）")]),v._v("，假设A的初始序列号为1000，以该序列号为原点，对自己将要发送的"),e("strong",[v._v("每个字节的数据进行编号")]),v._v("，1001，1002，1003..，"),e("strong",[v._v("并把自己的初始序列号ISN告诉B，让B有一个思想准备，什么样编号的数据是合法的，什么编号是非法的，比如编号900就是非法的")]),v._v("，同时B还可以对A每一个编号的字节数据进行确认。如果A收到B确认编号为2001，则意味着字节编号为1001-2000，共1000个字节已经安全到达。")]),v._v(" "),e("p",[v._v("同理B也是类似的操作，假设B的初始序列号ISN为2000，以该序列号为原点，对自己将要发送的每个字节的数据进行编号，2001，2002，2003..，并把自己的初始序列号ISN告诉A，以便A可以确认B发送的每一个字节。如果B收到A确认编号为4001，则意味着字节编号为2001-4000，共2000个字节已经安全到达。")]),v._v(" "),e("p",[e("strong",[v._v("一句话概括，TCP连接握手，握的是啥？")]),v._v(" "),e("strong",[v._v("通信双方数据原点的序列号！")])]),v._v(" "),e("p",[v._v("以此核心思想我们来分析"),e("strong",[v._v("二、三、四次握手")]),v._v("的过程。")]),v._v(" "),e("p",[v._v("A<-------\x3eB"),e("strong",[v._v("四次握手")]),v._v("的过程：\n"),e("strong",[v._v("1.1")]),v._v(" A发送同步信号SYN+A's Initial sequence number\n"),e("strong",[v._v("1.2")]),v._v(" B确认收到A的同步信号，并记录A's ISN到本地，命名B'sACK sequence number\n"),e("strong",[v._v("1.3")]),v._v(" B发送同步信号SYN+B's Initial sequence number\n"),e("strong",[v._v("1.4")]),v._v(" A确认收到B的同步信号，并记录B'sISN到本地，命名A's ACK sequence number")]),v._v(" "),e("p",[v._v("很显然1.2和1.3这两个步骤可以合并，只需要三次握手，可以提高连接的速度与效率。")]),v._v(" "),e("p",[v._v("A<-------\x3eB"),e("strong",[v._v("二次握手")]),v._v("的过程：\n"),e("strong",[v._v("2.1")]),v._v(" A发送同步信号"),e("strong",[v._v("SYN")]),v._v(" + "),e("strong",[v._v("A's Initial sequence number")]),v._v(" "),e("strong",[v._v("2.2")]),v._v(" B发送同步信号"),e("strong",[v._v("SYN")]),v._v(" + "),e("strong",[v._v("B's Initial sequence number")]),v._v(" + "),e("strong",[v._v("B's ACK sequence number")])]),v._v(" "),e("p",[v._v("这里有一个问题，A与B就A的初始序列号达成了一致，这里是1000。但是B无法知道A是否已经接收到自己的同步信号，如果这个同步信号丢失了，A和B就B的初始序列号将无法达成一致。\n于是TCP的设计者将SYN这个同步标志位SYN设计成占用一个字节的编号（FIN标志位也是），既然是一个字节的数据，按照TCP对有数据的TCP segment必须确认的原则，所以在这里A必须给B一个确认，以确认A已经接收到B的同步信号。")]),v._v(" "),e("p",[v._v("有童鞋会说，"),e("strong",[v._v("如果A发给B的确认丢了")]),v._v("，该如何？\nA会超时重传这个ACK吗？不会！"),e("strong",[v._v("TCP不会为没有数据的ACK超时重传。")]),v._v("\n那该如何是好？"),e("strong",[v._v("B如果没有收到A的ACK，会超时重传自己的SYN同步信号，一直到收到A的ACK为止")])]),v._v(" "),e("hr"),v._v(" "),e("p",[e("strong",[v._v("丢包补充：")]),v._v("\n第一个包，即A发给B的SYN中途被丢，没有到达B ，A会周期性超时重传，直到收到B的确认\n第二个包，即B发给A的SYN+ACK中途被丢，没有到达A，B会周期性超时重传，直到收到A的确认\n第三个包，即A发给B的ACK中途被丢，没有到达B，A发完ACK，单方面认为TCP为Established状态，而B显然认为TCP为Active状态：")]),v._v(" "),e("p",[e("strong",[v._v("a.")]),v._v(" 假定此时双方都没有数据发送，B会周期性超时重传，直到收到A的确认，收到之后B的TCP连接也为Established状态，双向可以发包。\n"),e("strong",[v._v("b.")]),v._v(" 假定此时A有数据发送，B收到A的Data+ACK，自然会切换为established状态，并接受A的Data。\n"),e("strong",[v._v("c.")]),v._v(" 假定B有数据发送，数据发送不了，会一直周期性超时重传SYN+ACK，直到收到A的确认才可以发送数据。")]),v._v(" "),e("p",[e("strong",[v._v("TCP 协议是不限制一个特定的连接（两端 socket 一样）被重复使用的。")])]),v._v(" "),e("p",[v._v("所以这样就有一个问题：")]),v._v(" "),e("p",[e("strong",[v._v("这条连接突然断开重连后，TCP 怎么样识别之前旧链接重发的包？")]),v._v("——这就需要独一无二的 "),e("strong",[v._v("ISN（初始序列号）机制。")])]),v._v(" "),e("p",[v._v("当一个新连接建立时，"),e("code",[v._v("初始序列号（ initial sequence number ISN）生成器")]),v._v("会生成一个新的32位的 ISN。")]),v._v(" "),e("p",[v._v("这个生成器会用一个32位长的时钟，差不多"),e("code",[v._v("4µs")]),v._v(" 增长一次，因此 ISN 会在大约 4.55 小时循环一次")]),v._v(" "),e("p",[v._v("（"),e("code",[v._v("2^32")]),v._v("位的计数器，需要"),e("code",[v._v("2^32*4 µs")]),v._v("才能自增完，除以1小时共有多少µs便可算出"),e("code",[v._v("2^32*4 /(1*60*60*1000*1000)=4.772185884")]),v._v(" ）")]),v._v(" "),e("p",[v._v("而一个报文段在网络中并不会比"),e("strong",[v._v("最大报文段寿命（Maximum Segment Lifetime (MSL)")]),v._v(" ，默认使用"),e("strong",[v._v("2分钟")]),v._v("）长，MSL 比4.55小时要短，所以我们可以认为 ISN 会是唯一的。")]),v._v(" "),e("p",[v._v("发送方与接收方都会有自己的 ISN （下面的例子中就是 X 与 Y）来做双方互发通信，具体的描述如下：")]),v._v(" "),e("blockquote",[e("ol",[e("li",[e("p",[v._v("A --\x3e B  SYN my sequence number is X")])]),v._v(" "),e("li",[e("p",[v._v("A <-- B  ACK your sequence number is X")])]),v._v(" "),e("li",[e("p",[v._v("A <-- B  SYN my sequence number is Y")])]),v._v(" "),e("li",[e("p",[v._v("A --\x3e B  ACK your sequence number is Y")])])])]),v._v(" "),e("p",[v._v("2与3都是 "),e("strong",[v._v("B 发送给 A，因此可以合并在一起")]),v._v("，因此成为"),e("code",[v._v("three way (or three message) handshake")]),v._v("（其实翻译为三步握手，或者是三次通信握手更为准确）")]),v._v(" "),e("p",[v._v("因此最终可以得出，三次握手是必须的。")]),v._v(" "),e("p",[e("strong",[v._v("三次握手的原则设计")]),v._v("是"),e("strong",[v._v("防止旧复用链接的初始化导致问题")]),v._v("，为了解决此问题，我们设计了"),e("code",[v._v("reset")]),v._v("这个特别的控制信号来处理。")]),v._v(" "),e("p",[v._v("如果"),e("strong",[v._v("接收中的 TCP 在一个未同步状态如 "),e("code",[v._v("SYN-SENT, SYN-RECEIVED")]),v._v("，它会返回 "),e("code",[v._v("reset")]),v._v(" 给对方。")])]),v._v(" "),e("p",[v._v("如果 "),e("strong",[v._v("TCP 是同步状态中如"),e("code",[v._v("(ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT)")]),v._v("，他会终止此连接并通知用户。")])]),v._v(" "),e("p",[v._v("看起来有点绕，我们举个图例看看：")]),v._v(" "),e("div",{staticClass:"language-text extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[v._v("     TCP A                                                TCP B\n\n  1.  CLOSED                                               LISTEN\n\n  2.  SYN-SENT    --\x3e <SEQ=100><CTL=SYN>               ...\n\n  3.  (duplicate) ... <SEQ=90><CTL=SYN>               --\x3e SYN-RECEIVED\n\n  4.  SYN-SENT    <-- <SEQ=300><ACK=91><CTL=SYN,ACK>  <-- SYN-RECEIVED\n\n  5.  SYN-SENT    --\x3e <SEQ=91><CTL=RST>               --\x3e LISTEN\n\n  6.              ... <SEQ=100><CTL=SYN>               --\x3e SYN-RECEIVED\n\n  7.  SYN-SENT    <-- <SEQ=400><ACK=101><CTL=SYN,ACK>  <-- SYN-RECEIVED\n\n  8.  ESTABLISHED --\x3e <SEQ=101><ACK=401><CTL=ACK>      --\x3e ESTABLISHED\n\n                    Recovery from Old Duplicate SYN\n")])])]),e("p",[v._v("这是 复用连接时，旧包比新连接的包先到B端的例子。")]),v._v(" "),e("ul",[e("li",[v._v("3中，一个旧的重复的 "),e("code",[v._v("SYN")]),v._v("到达 "),e("code",[v._v("B")]),v._v("。")]),v._v(" "),e("li",[v._v("4中， "),e("code",[v._v("B")]),v._v("分别不出是否旧的，照样子正常回包。")]),v._v(" "),e("li",[v._v("5中，"),e("code",[v._v("A")]),v._v("检测到 "),e("code",[v._v("B")]),v._v(" 返回的"),e("code",[v._v("ACK")]),v._v("不正确，所以返回 "),e("code",[v._v("RST(reset)")])]),v._v(" "),e("li",[v._v("6中，"),e("code",[v._v("B")]),v._v("接收到  "),e("code",[v._v("RST(reset)")]),v._v("信号，于是变成 "),e("code",[v._v("LISTEN")]),v._v(" 状态。")]),v._v(" "),e("li",[v._v("7中，新连接正常的 "),e("code",[v._v("SYN")]),v._v("终于到达了，三次握手正常进行。")])]),v._v(" "),e("p",[v._v("这种是简化的情况，但是可以看出 TCP 是如何处理复用旧链接的包到达的。")]),v._v(" "),e("h3",{attrs:{id:"为什么不是两次？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么不是两次？","aria-hidden":"true"}},[v._v("#")]),v._v(" 为什么不是两次？")]),v._v(" "),e("p",[v._v("根本原因: 无法确认客户端的接收能力。")]),v._v(" "),e("p",[v._v("分析如下:")]),v._v(" "),e("p",[v._v("如果是两次，你现在发了 SYN 报文想握手，但是这个包"),e("strong",[v._v("滞留")]),v._v("在了当前的网络中迟迟没有到达，TCP 以为这是丢了包，于是重传，两次握手建立好了连接。")]),v._v(" "),e("p",[v._v("看似没有问题，但是连接关闭后，如果这个"),e("strong",[v._v("滞留")]),v._v("在网路中的包到达了服务端呢？这时候由于是两次握手，服务端只要接收到然后发送相应的数据包，就默认"),e("strong",[v._v("建立连接")]),v._v("，但是现在客户端已经断开了。")]),v._v(" "),e("p",[v._v("看到问题的吧，这就带来了连接资源的浪费。")]),v._v(" "),e("h3",{attrs:{id:"为什么不是四次？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么不是四次？","aria-hidden":"true"}},[v._v("#")]),v._v(" 为什么不是四次？")]),v._v(" "),e("p",[v._v("三次握手的目的是确认双方发送和接收的能力，那四次握手可以嘛？")]),v._v(" "),e("p",[v._v("当然可以，100 次都可以。但为了解决问题，三次就足够了，再多用处就不大了。")]),v._v(" "),e("h3",{attrs:{id:"三次握手过程中可以携带数据么？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三次握手过程中可以携带数据么？","aria-hidden":"true"}},[v._v("#")]),v._v(" 三次握手过程中可以携带数据么？")]),v._v(" "),e("p",[v._v("第三次握手的时候，可以携带。前两次握手不能携带数据。")]),v._v(" "),e("p",[v._v("如果前两次握手能够携带数据，那么一旦有人想攻击服务器，那么他只需要在第一次握手中的 SYN 报文中放大量数据，那么服务器势必会消耗更多的"),e("strong",[v._v("时间")]),v._v("和"),e("strong",[v._v("内存空间")]),v._v("去处理这些数据，增大了服务器被攻击的风险。")]),v._v(" "),e("p",[v._v("第三次握手的时候，客户端已经处于ESTABLISHED状态，并且已经能够确认服务器的接收、发送能力正常，这个时候相对安全了，可以携带数据。")]),v._v(" "),e("h3",{attrs:{id:"同时打开会怎样？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#同时打开会怎样？","aria-hidden":"true"}},[v._v("#")]),v._v(" 同时打开会怎样？")]),v._v(" "),e("p",[v._v("如果双方同时发 SYN报文，状态变化会是怎样的呢？")]),v._v(" "),e("p",[v._v("这是一个可能会发生的情况。")]),v._v(" "),e("p",[v._v("状态变迁如下:")]),v._v(" "),e("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://pic1.zhimg.com/80/v2-c99d5f1fe9d483073ff358adab8e4e24_720w.jpg",alt:"img"}}),v._v(" "),e("p",[v._v("在发送方给接收方发SYN报文的同时，接收方也给发送方发SYN报文，两个人刚上了!")]),v._v(" "),e("p",[v._v("发完SYN，两者的状态都变为SYN-SENT。")]),v._v(" "),e("p",[v._v("在各自收到对方的SYN后，两者状态都变为SYN-REVD。")]),v._v(" "),e("p",[v._v("接着会回复对应的ACK + SYN，这个报文在对方接收之后，两者状态一起变为ESTABLISHED。")]),v._v(" "),e("p",[v._v("这就是同时打开情况下的状态变迁。")])])}),[],!1,null,null,null);_.default=s.exports}}]);