(window.webpackJsonp=window.webpackJsonp||[]).push([[96],{350:function(t,v,r){"use strict";r.r(v);var _=r(2),e=Object(_.a)({},(function(){var t=this,v=t.$createElement,r=t._self._c||v;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"_005-说说半连接队列和-syn-flood-攻击的关系"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_005-说说半连接队列和-syn-flood-攻击的关系","aria-hidden":"true"}},[t._v("#")]),t._v(" 005-说说半连接队列和 SYN Flood 攻击的关系")]),t._v(" "),r("p",[t._v("三次握手前，服务端的状态从CLOSED变为LISTEN, 同时在内部创建了两个队列："),r("strong",[t._v("半连接队列")]),t._v("和"),r("strong",[t._v("全连接队列")]),t._v("，即"),r("strong",[t._v("SYN队列")]),t._v("和"),r("strong",[t._v("ACCEPT队列")]),t._v("。")]),t._v(" "),r("h3",{attrs:{id:"半连接队列（syn队列）"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#半连接队列（syn队列）","aria-hidden":"true"}},[t._v("#")]),t._v(" 半连接队列（SYN队列）")]),t._v(" "),r("p",[t._v("当客户端发送SYN到服务端，服务端收到以后回复ACK和SYN，状态由LISTEN变为SYN_RCVD，此时这个连接就被推入了"),r("strong",[t._v("SYN队列")]),t._v("，也就是"),r("strong",[t._v("半连接队列")]),t._v("。")]),t._v(" "),r("h3",{attrs:{id:"全连接队列（accept队列）"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#全连接队列（accept队列）","aria-hidden":"true"}},[t._v("#")]),t._v(" 全连接队列（ACCEPT队列）")]),t._v(" "),r("p",[t._v("当客户端返回ACK, 服务端接收后，三次握手完成。这个时候连接等待被具体的应用取走，在被取走之前，它会被推入另外一个 TCP 维护的队列，也就是"),r("strong",[t._v("全连接队列(Accept Queue)")]),t._v("。")]),t._v(" "),r("h3",{attrs:{id:"syn-flood-攻击原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#syn-flood-攻击原理","aria-hidden":"true"}},[t._v("#")]),t._v(" SYN Flood 攻击原理")]),t._v(" "),r("p",[t._v("SYN Flood 属于典型的 DoS/DDoS (Denial of Service/Distributed Denial of Service)攻击。服务器端的资源分配是在"),r("strong",[t._v("二次握手")]),t._v("时分配的，而"),r("strong",[t._v("客户端的资源是在完成三次握手时分配")]),t._v("的，所以服务器容易受到SYN洪泛攻击。")]),t._v(" "),r("p",[t._v("SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。")]),t._v(" "),r("p",[t._v("其攻击的原理很简单，就是用客户端在短时间内伪造大量不存在的 IP 地址，并向服务端疯狂发送SYN。对于服务端而言，会产生两个危险的后果:")]),t._v(" "),r("ol",[r("li",[t._v("处理大量的SYN包并返回对应ACK, 势必有大量连接处于SYN_RCVD状态，从而占满整个"),r("strong",[t._v("半连接队列")]),t._v("，无法处理正常的请求。")]),t._v(" "),r("li",[t._v("由于是不存在的 IP，服务端长时间收不到客户端的ACK，会导致服务端不断重发数据，直到耗尽服务端的资源。")])]),t._v(" "),r("p",[t._v("检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("netstat -n -p TCP | grep SYN_RECV\n")])])]),r("h3",{attrs:{id:"如何应对-syn-flood-攻击？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#如何应对-syn-flood-攻击？","aria-hidden":"true"}},[t._v("#")]),t._v(" 如何应对 SYN Flood 攻击？")]),t._v(" "),r("ol",[r("li",[t._v("增加 SYN 连接，也就是"),r("strong",[t._v("增加半连接队列的容量，增加最大半连接数。")])]),t._v(" "),r("li",[r("strong",[t._v("减少 SYN + ACK 重传次数")]),t._v("，避免大量的超时重发。")]),t._v(" "),r("li",[t._v("利用 "),r("strong",[t._v("SYN Cookie 技术")]),t._v("，在服务端接收到SYN后"),r("strong",[t._v("不立即分配连接资源")]),t._v("，而是"),r("strong",[t._v("根据这个SYN计算出一个Cookie")]),t._v("，连同第二次握手回复给客户端，在客户端回复ACK的时候带上这个Cookie值，"),r("strong",[t._v("服务端验证 Cookie 合法之后才分配连接资源。")])]),t._v(" "),r("li",[t._v("过滤网关防护")])])])}),[],!1,null,null,null);v.default=e.exports}}]);