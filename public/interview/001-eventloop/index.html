<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>001: 说说事件循环机制(JS的执行机制) | Half Town前端周刊</title>
    <meta name="description" content="白糖炒栗子哒前端Blog">
    <link rel="icon" href="/favicon.ico">
  <link rel="mainfest" href="/mainfest.json">
    
    <link rel="preload" href="/assets/css/0.styles.d4c32f31.css" as="style"><link rel="preload" href="/assets/js/app.b1906b97.js" as="script"><link rel="preload" href="/assets/js/2.bdee5faf.js" as="script"><link rel="preload" href="/assets/js/5.06355c1f.js" as="script"><link rel="preload" href="/assets/js/7.f0379e88.js" as="script"><link rel="preload" href="/assets/js/8.e132ed9d.js" as="script"><link rel="prefetch" href="/assets/js/10.e085a21c.js"><link rel="prefetch" href="/assets/js/100.78a0b04f.js"><link rel="prefetch" href="/assets/js/101.02ef3e98.js"><link rel="prefetch" href="/assets/js/102.cdd542e1.js"><link rel="prefetch" href="/assets/js/103.de748a03.js"><link rel="prefetch" href="/assets/js/104.7455cba5.js"><link rel="prefetch" href="/assets/js/105.68a805c9.js"><link rel="prefetch" href="/assets/js/106.a2ff7e85.js"><link rel="prefetch" href="/assets/js/107.36f34ab6.js"><link rel="prefetch" href="/assets/js/108.f26732f6.js"><link rel="prefetch" href="/assets/js/109.8d05e086.js"><link rel="prefetch" href="/assets/js/11.f2fd41dc.js"><link rel="prefetch" href="/assets/js/110.c7f84bd1.js"><link rel="prefetch" href="/assets/js/111.0cdf0d73.js"><link rel="prefetch" href="/assets/js/12.450e705b.js"><link rel="prefetch" href="/assets/js/13.50973e7a.js"><link rel="prefetch" href="/assets/js/14.40fad099.js"><link rel="prefetch" href="/assets/js/15.a2d432ad.js"><link rel="prefetch" href="/assets/js/16.4ad6c82f.js"><link rel="prefetch" href="/assets/js/17.1bc86885.js"><link rel="prefetch" href="/assets/js/18.ade73665.js"><link rel="prefetch" href="/assets/js/19.a0f47a6e.js"><link rel="prefetch" href="/assets/js/20.5499b902.js"><link rel="prefetch" href="/assets/js/21.86afe090.js"><link rel="prefetch" href="/assets/js/22.29fa6f17.js"><link rel="prefetch" href="/assets/js/23.1af6f734.js"><link rel="prefetch" href="/assets/js/24.933ea1dd.js"><link rel="prefetch" href="/assets/js/25.7b5dc5f0.js"><link rel="prefetch" href="/assets/js/26.03194069.js"><link rel="prefetch" href="/assets/js/27.eb1fac5c.js"><link rel="prefetch" href="/assets/js/28.01df134d.js"><link rel="prefetch" href="/assets/js/29.697d4c02.js"><link rel="prefetch" href="/assets/js/3.77f61fb0.js"><link rel="prefetch" href="/assets/js/30.e1b58026.js"><link rel="prefetch" href="/assets/js/31.41db2b44.js"><link rel="prefetch" href="/assets/js/32.9f2db749.js"><link rel="prefetch" href="/assets/js/33.03b6d68a.js"><link rel="prefetch" href="/assets/js/34.09609909.js"><link rel="prefetch" href="/assets/js/35.c80be0ac.js"><link rel="prefetch" href="/assets/js/36.d15e6050.js"><link rel="prefetch" href="/assets/js/37.1ccd8184.js"><link rel="prefetch" href="/assets/js/38.ab0d4b98.js"><link rel="prefetch" href="/assets/js/39.8301eaad.js"><link rel="prefetch" href="/assets/js/4.90b687b0.js"><link rel="prefetch" href="/assets/js/40.d95907af.js"><link rel="prefetch" href="/assets/js/41.33845e14.js"><link rel="prefetch" href="/assets/js/42.8a256266.js"><link rel="prefetch" href="/assets/js/43.343b309f.js"><link rel="prefetch" href="/assets/js/44.e61b9da2.js"><link rel="prefetch" href="/assets/js/45.0eea8be7.js"><link rel="prefetch" href="/assets/js/46.861203d9.js"><link rel="prefetch" href="/assets/js/47.ae5bd907.js"><link rel="prefetch" href="/assets/js/48.1dbfd265.js"><link rel="prefetch" href="/assets/js/49.87f2ea7e.js"><link rel="prefetch" href="/assets/js/50.92bcf9cd.js"><link rel="prefetch" href="/assets/js/51.2b54e26b.js"><link rel="prefetch" href="/assets/js/52.ef61db16.js"><link rel="prefetch" href="/assets/js/53.e8411588.js"><link rel="prefetch" href="/assets/js/54.6f0a7cd7.js"><link rel="prefetch" href="/assets/js/55.40d0a721.js"><link rel="prefetch" href="/assets/js/56.76ff8ce6.js"><link rel="prefetch" href="/assets/js/57.cfea78e2.js"><link rel="prefetch" href="/assets/js/58.f8c35f3d.js"><link rel="prefetch" href="/assets/js/59.02cbb18a.js"><link rel="prefetch" href="/assets/js/6.d108277e.js"><link rel="prefetch" href="/assets/js/60.2df7b32b.js"><link rel="prefetch" href="/assets/js/61.16805fc4.js"><link rel="prefetch" href="/assets/js/62.ef5ca102.js"><link rel="prefetch" href="/assets/js/63.923718a5.js"><link rel="prefetch" href="/assets/js/64.d40092dd.js"><link rel="prefetch" href="/assets/js/65.d68a358c.js"><link rel="prefetch" href="/assets/js/66.b4323cbe.js"><link rel="prefetch" href="/assets/js/67.3a9004c1.js"><link rel="prefetch" href="/assets/js/68.350f6fbb.js"><link rel="prefetch" href="/assets/js/69.fdebae43.js"><link rel="prefetch" href="/assets/js/70.ccac64ba.js"><link rel="prefetch" href="/assets/js/71.8948f6c8.js"><link rel="prefetch" href="/assets/js/72.f5d07472.js"><link rel="prefetch" href="/assets/js/73.c2ddba1b.js"><link rel="prefetch" href="/assets/js/74.7a96d852.js"><link rel="prefetch" href="/assets/js/75.d452b4b5.js"><link rel="prefetch" href="/assets/js/76.5eac82cb.js"><link rel="prefetch" href="/assets/js/77.49a8f94c.js"><link rel="prefetch" href="/assets/js/78.17478c01.js"><link rel="prefetch" href="/assets/js/79.545a2920.js"><link rel="prefetch" href="/assets/js/80.172aeb42.js"><link rel="prefetch" href="/assets/js/81.6376c78a.js"><link rel="prefetch" href="/assets/js/82.1dfa8f89.js"><link rel="prefetch" href="/assets/js/83.fc10680d.js"><link rel="prefetch" href="/assets/js/84.41df0212.js"><link rel="prefetch" href="/assets/js/85.b57d2894.js"><link rel="prefetch" href="/assets/js/86.1bed09b1.js"><link rel="prefetch" href="/assets/js/87.3bc2e0cf.js"><link rel="prefetch" href="/assets/js/88.5797d5a1.js"><link rel="prefetch" href="/assets/js/89.cfc4d086.js"><link rel="prefetch" href="/assets/js/9.17617c7c.js"><link rel="prefetch" href="/assets/js/90.d3796c5b.js"><link rel="prefetch" href="/assets/js/91.f9e0f122.js"><link rel="prefetch" href="/assets/js/92.8ce6ae6a.js"><link rel="prefetch" href="/assets/js/93.f1c144ce.js"><link rel="prefetch" href="/assets/js/94.1877adf1.js"><link rel="prefetch" href="/assets/js/95.41ce2c18.js"><link rel="prefetch" href="/assets/js/96.07be3e30.js"><link rel="prefetch" href="/assets/js/97.d6ecd209.js"><link rel="prefetch" href="/assets/js/98.b1431a2d.js"><link rel="prefetch" href="/assets/js/99.acea4094.js">
    <link rel="stylesheet" href="/assets/css/0.styles.d4c32f31.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Half Town前端周刊</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/posts/" class="nav-link">目录</a></div><div class="nav-item"><a href="https://github.com/LSKReno" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">其他</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://weibo.com/u/5092674629" target="_blank" rel="noopener noreferrer" class="nav-link external">
  微博
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="http://lskreno.vip" target="_blank" rel="noopener noreferrer" class="nav-link external">
  LSKReno的 博客
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/posts/" class="nav-link">目录</a></div><div class="nav-item"><a href="https://github.com/LSKReno" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">其他</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://weibo.com/u/5092674629" target="_blank" rel="noopener noreferrer" class="nav-link external">
  微博
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="http://lskreno.vip" target="_blank" rel="noopener noreferrer" class="nav-link external">
  LSKReno的 博客
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/posts/" class="sidebar-link">目录</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>总结前端技术文章</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>HTML</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>CSS</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JavaScript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>ES6-11新特性</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>深入JavaScript系列</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Browser浏览器</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JS-API揭秘系列</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>搞懂那个TCP</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>这个面试不太难</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/interview/001-eventloop/" class="active sidebar-link">001: 说说事件循环机制(JS的执行机制)</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/interview/001-eventloop/#思维导图" class="sidebar-link">思维导图</a></li><li class="sidebar-sub-header"><a href="/interview/001-eventloop/#_1-为什么-javascript-是单线程的？" class="sidebar-link">1. 为什么 JavaScript 是单线程的？</a></li><li class="sidebar-sub-header"><a href="/interview/001-eventloop/#_2-单线程架构的优势和劣势" class="sidebar-link">2. 单线程架构的优势和劣势</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/interview/001-eventloop/#优势：" class="sidebar-link">优势：</a></li><li class="sidebar-sub-header"><a href="/interview/001-eventloop/#劣势：" class="sidebar-link">劣势：</a></li></ul></li><li class="sidebar-sub-header"><a href="/interview/001-eventloop/#_3-同步、异步和阻塞、非阻塞" class="sidebar-link">3. 同步、异步和阻塞、非阻塞</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/interview/001-eventloop/#同步和异步（消息通信机制）" class="sidebar-link">同步和异步（消息通信机制）</a></li><li class="sidebar-sub-header"><a href="/interview/001-eventloop/#阻塞和非阻塞（等待结果时，线程的状态）" class="sidebar-link">阻塞和非阻塞（等待结果时，线程的状态）</a></li></ul></li><li class="sidebar-sub-header"><a href="/interview/001-eventloop/#_4-执行栈（执行上下文）" class="sidebar-link">4. 执行栈（执行上下文）</a></li><li class="sidebar-sub-header"><a href="/interview/001-eventloop/#_5-js单线程存在的问题-单线程是如何实现异步的" class="sidebar-link">5. JS单线程存在的问题(单线程是如何实现异步的)</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/interview/001-eventloop/#_1-一些基本概念" class="sidebar-link">(1)一些基本概念</a></li><li class="sidebar-sub-header"><a href="/interview/001-eventloop/#_2-浏览器中的事件循环" class="sidebar-link">(2)浏览器中的事件循环</a></li><li class="sidebar-sub-header"><a href="/interview/001-eventloop/#_3-当-event-loop-遇到-async-await" class="sidebar-link">(3)当 Event Loop 遇到 async/await</a></li><li class="sidebar-sub-header"><a href="/interview/001-eventloop/#_4-node-中的事件循环" class="sidebar-link">(4)node 中的事件循环</a></li><li class="sidebar-sub-header"><a href="/interview/001-eventloop/#node-版本差异说明" class="sidebar-link">node 版本差异说明</a></li><li class="sidebar-sub-header"><a href="/interview/001-eventloop/#node-和-浏览器-eventloop的主要区别" class="sidebar-link">node 和 浏览器 eventLoop的主要区别</a></li></ul></li></ul></li><li><a href="/interview/002-closure/" class="sidebar-link">002: 闭包</a></li><li><a href="/interview/003-cross-orign/" class="sidebar-link">003:前端跨域问题</a></li><li><a href="/interview/004-js-7-inherits/" class="sidebar-link">004:JavaScript七大继承完爆面试</a></li><li><a href="/interview/005-cookie/" class="sidebar-link">005: 这个cookie不太难</a></li><li><a href="/interview/006-garbage-collection/" class="sidebar-link">006:JS的垃圾回收机制</a></li><li><a href="/interview/007-regexp/" class="sidebar-link">007:正则表达式</a></li><li><a href="/interview/008-0.3=0.1+0.2/" class="sidebar-link">008:从判断 0.1 + 0.2 与 0.3 是否相等引发出的知识</a></li><li><a href="/interview/009-eventmodel/" class="sidebar-link">JavaScript事件模型</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>手写JS系列</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Vue大赏</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Koa大赏</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>MongoDB大赏</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JS设计模式</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端安全</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端架构设计</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端模块化规范</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>操作系统</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端自动化测试</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Vue-cli的配置详解</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>关于</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="_001-说说事件循环机制-js的执行机制"><a href="#_001-说说事件循环机制-js的执行机制" aria-hidden="true" class="header-anchor">#</a> 001: 说说事件循环机制(JS的执行机制)</h1> <p><div data-v-21553e4a><p data-v-21553e4a><strong data-v-21553e4a>Hey mate, Please know that</strong></p> <div data-v-21553e4a>坚持比努力更可怕</div> <div class="seperator" data-v-21553e4a></div></div></p> <blockquote><p>Event Loop 超棒演讲视频</p></blockquote> <video src="https://outin-2da6e967af7111ea960800163e1a65b6.oss-cn-shanghai.aliyuncs.com/sv/27b2aecf-172bac29ecc/27b2aecf-172bac29ecc.mp4?Expires=1592295614&amp;OSSAccessKeyId=LTAIVVfYx6D0HeL2&amp;Signature=P8qULn%2F%2BTfn%2FBMy1uVkAsb3qGfM%3D" controls="controls" style="width:40vw;">
your browser does not support the video tag
</video> <h2 id="思维导图"><a href="#思维导图" aria-hidden="true" class="header-anchor">#</a> 思维导图</h2> <ol><li>基本知识点，宏任务、微任务有哪些</li> <li>事件循环机制过程，边说边画图出来</li> <li>说async/await执行顺序注意，可以把 chrome 的优化，做法其实是违法了规范的，V8 团队的PR这些自信点说出来，显得你很好学，理解得很详细，很透彻。</li> <li>把node的事件循环也说一下，重复1、2、3点，node中的第3点要说的是node11前后的事件循环变动点。</li></ol> <p>Event Loop 过程</p> <p>一个完整的 Event Loop 过程，可以概括为以下阶段：</p> <ol><li><p>初始状态：调用栈空。微任务(micro)队列空，宏任务(macro)队列里有且只有一个 script 脚本（整体代码）。</p></li> <li><p>第一步：全局上下文（script 标签）被推入调用栈，同步代码执行。在执行的过程中，通过对一些接口的调用，可以产生新的宏任务与微任务，它们会分别被推入各自的任务队列里。同步代码执行完了，script 脚本会被移出宏任务队列，这个过程本质上是队列的 macro-task 的执行和出队的过程。</p></li> <li><p>第二步：我们处理的是微任务。但需要注意的是：当宏任务出队时，任务是一个一个执行的；而微任务出队时，任务是一队一队执行的（如下图所示）。因此，处理微任务队列时，会逐个执行队列中的任务并把它出队，直到队列被清空。</p></li> <li><p>第三步：执行渲染操作，更新界面（敲黑板划重点）。注意：在执行渲染操作之前如果有RAF则会先调用RAF操作(requestAnimationFrame()函数)</p></li> <li><p>第四步：检查是否存在 Web worker 任务，如果有，则对其进行处理 。</p></li></ol> <p>（上述过程循环往复，直到两个队列都清空）</p> <p>注意：在第二步中事件队列中分“宏任务队列”和“微任务队列”，每执行一次任务都可能注册新的宏任务或微任务到相应的任务队列中，只要遵循“每执行一个宏任务，就会清空一次事件队列中的所有微任务”这一循环规则，就不会弄乱。</p> <h2 id="_1-为什么-javascript-是单线程的？"><a href="#_1-为什么-javascript-是单线程的？" aria-hidden="true" class="header-anchor">#</a> 1. 为什么 JavaScript 是单线程的？</h2> <p>因为 JS 是一门单线程的编程语言，也就是说同一时间只能做一件事。</p> <ol><li><p>这是因为 JavaScript 生来作为浏览器脚本语言，主要用来处理与用户的交互、网络以及操作 DOM。这就决定了它只能是单线程的，否则会带来很复杂的同步问题。</p> <p>假设 JavaScript 有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器就不知道该以那个县城为准了。</p></li> <li><p>为了简单，从一开始<strong>JavaScript就是单线程</strong>，单线程，事件循环机制已经成为JS的核心。</p></li> <li><p>为了利用多核CPU的计算能力，H5的Web Worker实现的“多线程”实际上指的是“多子线程”，完全受控于主线程，且不允许操作DOM；</p></li></ol> <h2 id="_2-单线程架构的优势和劣势"><a href="#_2-单线程架构的优势和劣势" aria-hidden="true" class="header-anchor">#</a> 2. 单线程架构的优势和劣势</h2> <h3 id="优势："><a href="#优势：" aria-hidden="true" class="header-anchor">#</a> 优势：</h3> <ul><li>单线程省去了线程间切换的开销</li> <li>无需关注线程间的状态同步</li> <li>无需关注死锁</li></ul> <h3 id="劣势："><a href="#劣势：" aria-hidden="true" class="header-anchor">#</a> 劣势：</h3> <ul><li>无法充分利用多核CPU</li> <li>单线程架构，一旦主线程崩溃，整个进程就会崩溃，也就是整个应用就崩溃了。</li> <li>大量计算占用CPU会导致应用阻塞(即不适用CPU密集型)</li></ul> <blockquote><p><strong>为了防止主线程的阻塞，JavaScript 有了 同步 和 异步 的概念。</strong></p></blockquote> <h2 id="_3-同步、异步和阻塞、非阻塞"><a href="#_3-同步、异步和阻塞、非阻塞" aria-hidden="true" class="header-anchor">#</a> 3. 同步、异步和阻塞、非阻塞</h2> <h3 id="同步和异步（消息通信机制）"><a href="#同步和异步（消息通信机制）" aria-hidden="true" class="header-anchor">#</a> 同步和异步（消息通信机制）</h3> <ul><li>同步：同步方法调用一旦开始，调用者必须等到该函数调用返回后，才能继续后续的行为。</li> <li>异步：如果在函数返回的时候，调用者还不能够得到预期结果，而是被调用者在将来通过状态、通知等手段告知调用者，那么这个函数就是异步的。典型的异步编程模型比如 Node.js</li></ul> <h3 id="阻塞和非阻塞（等待结果时，线程的状态）"><a href="#阻塞和非阻塞（等待结果时，线程的状态）" aria-hidden="true" class="header-anchor">#</a> 阻塞和非阻塞（等待结果时，线程的状态）</h3> <ul><li>阻塞：在等待调用结果时，线程挂起了，不往下执行</li> <li>非阻塞：与上面相反，当前线程继续往下执行</li></ul> <h2 id="_4-执行栈（执行上下文）"><a href="#_4-执行栈（执行上下文）" aria-hidden="true" class="header-anchor">#</a> 4. 执行栈（执行上下文）</h2> <p>栈 (stack): 栈是遵循后进先出 (LIFO) 原则的有序集合.</p> <p>队列 (queue): 队列是遵循先进先出 (FIFO) 原则的有序集合。</p> <p>堆 (heap): 堆是基于树抽象数据类型的一种特殊的数据结构。</p> <p>JavaScript 中的内存分为 <code>堆内存</code> 和 <code>栈内存</code> ,</p> <p>JavaScript 中引用类型值的大小是不固定的，因此它们会被存储到 堆内存 中，由系统自动分配存储空间。JavaScript 不允许直接访问堆内存中的位置，因此我们不能直接操作对象的堆内存空间，而是操作 对象的引用。</p> <p>而 JavaScript 中的基础数据类型都有固定的大小，因此它们被存储到 栈内存 中。我们可以直接操作保存在栈内存空间的值，因此基础数据类型都是 按值访问。此外，栈内存还会存储 对象的引用 (指针) 以及 函数执行时的运行空间。</p> <p>下面比较一下两种存储方式的不同。</p> <table><thead><tr><th>栈内存</th> <th>堆内存</th></tr></thead> <tbody><tr><td>存储基础数据类型</td> <td>存储引用数据类型</td></tr> <tr><td>按值访问</td> <td>按引用访问</td></tr> <tr><td>存储的值大小固定</td> <td>存储的值大小不定，可动态调整</td></tr> <tr><td>由系统自动分配内存空间</td> <td>由程序员通过代码进行分配</td></tr> <tr><td>主要用来执行程序</td> <td>主要用来存放对象</td></tr> <tr><td>空间小，运行效率高</td> <td>空间大，但是运行效率相对较低</td></tr> <tr><td>先进后出，后进先出</td> <td>无序存储，可根据引用直接获取</td></tr></tbody></table> <h2 id="_5-js单线程存在的问题-单线程是如何实现异步的"><a href="#_5-js单线程存在的问题-单线程是如何实现异步的" aria-hidden="true" class="header-anchor">#</a> 5. JS单线程存在的问题(单线程是如何实现异步的)</h2> <p>众所周知，js是单线程的，JavaScript的执行机制就是<strong>按照语句出现的顺序执行的</strong>，也就是说js是一行一行执行的。</p> <p>但是由于JS处理任务是一件接着一件处理的，所以，如果一个任务需要处理很久的话，后面的任务就会被阻塞。</p> <p>那么怎么解决呢？</p> <p>js通过Event Loop事件循环的方式解决了这个问题。</p> <p><img src="/assets/img/eventLoop.83c4c4f2.jpg" alt="eventLoop"></p> <p>JavaScript的任务分为两种，在主线程上执行的任务&quot;同步任务&quot;，被主线程挂载起来的任务&quot;异步任务&quot;, 后者一般是放在一个叫任务队列的数据结构中。</p> <h3 id="_1-一些基本概念"><a href="#_1-一些基本概念" aria-hidden="true" class="header-anchor">#</a> (1)一些基本概念</h3> <h4 id="_1-任务队列"><a href="#_1-任务队列" aria-hidden="true" class="header-anchor">#</a> 1. 任务队列</h4> <p>任务队列就是一个事件队列，其中最重要的是 <code>异步任务事件</code> 和 <code>定时事件</code> 。</p> <ul><li><p>异步任务事件：一般我们绑定一个事件，比如点击事件等等，都是在某一个时刻才触发执行的，这个时候就得放到任务队列里面，等待执行，而在某个DOM节点上绑定了事件，就要有相应的回调函数, 它们是相辅相成的。</p> <p>所谓回调函数，就是那些被挂载起来，等待执行的代码，主线程执行任务队列里面的异步任务，其实就是执行这些回调函数。</p></li> <li><p>定时事件：setInterval 和 setTimeout</p></li></ul> <h4 id="_2-同步任务和异步任务"><a href="#_2-同步任务和异步任务" aria-hidden="true" class="header-anchor">#</a> 2. 同步任务和异步任务</h4> <ul><li>同步任务(synchronous)：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；</li> <li>异步任务(asynchronous)：不进入主线程、而进入&quot;任务队列&quot;（task queue）的任务，只有&quot;任务队列&quot;通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。 (异步任务事件，定时事件，页面渲染请求图片获取异步资源等)</li></ul> <h4 id="_3-宏任务和微任务"><a href="#_3-宏任务和微任务" aria-hidden="true" class="header-anchor">#</a> 3. 宏任务和微任务</h4> <p>不同类型的任务会进入不同的Event Queue，有宏任务队列和微任务队列。</p> <p>这里需要注意的是new Promise是会进入到主线程中立刻执行，而promise.then则属于微任务。</p> <h3 id="_2-浏览器中的事件循环"><a href="#_2-浏览器中的事件循环" aria-hidden="true" class="header-anchor">#</a> (2)浏览器中的事件循环</h3> <p>JavaScript代码的执行过程中，除了依靠<strong>函数调用栈</strong>来搞定函数的执行顺序外，还依靠**任务队列(task queue)**来搞定另外一些代码的执行。整个执行过程，我们称为 <code>事件循环过程</code> 。</p> <p>一个线程中，事件循环是唯一的，但是任务队列可以拥有多个。任务队列又分为macro-task（宏任务）与micro-task（微任务），在最新标准中，它们被分别称为task与jobs。</p> <p>宏任务macro-task大概包括：</p> <ul><li>script(整体代码)</li> <li>setTimeout</li> <li>setInterval</li> <li>setImmediate（Nodejs）</li> <li>I/O</li> <li>UI render</li> <li>事件</li> <li>postMessage</li> <li>MessageChannel</li></ul> <p>微任务micro-task大概包括:</p> <ul><li>process.nextTick（Nodejs）</li> <li>Promise.then()</li> <li>Async/Await(实际就是promise)</li> <li>Object.observe</li> <li>MutationObserver(html5新特性)</li></ul> <p>整体执行，我画了一个流程图：</p> <p><img src="/assets/img/flow-chart.36ceabbc.png" alt=""></p> <p>总的结论就是，</p> <p>执行宏任务，然后执行该宏任务产生的微任务。</p> <p>若微任务在执行过程中产生了新的微任务，则继续执行微任务。</p> <p><strong>微任务全部执行完毕后，再回到宏任务中进行下一轮循环。</strong></p> <p>举个栗子：</p> <p><img src="/assets/img/example.10143dcf.png" alt=""></p> <p>结合流程图理解，答案输出为：async2 end =&gt; Promise =&gt; async1 end =&gt; promise1 =&gt; promise2 =&gt; setTimeout 但是，对于async/await ，我们有个细节还要处理一下。如下：</p> <h3 id="_3-当-event-loop-遇到-async-await"><a href="#_3-当-event-loop-遇到-async-await" aria-hidden="true" class="header-anchor">#</a> (3)当 Event Loop 遇到 async/await</h3> <p>我们知道 <code>async</code> 隐式返回 Promise 作为结果的函数, 那么可以简单理解为，await后面的函数执行完毕时，await会产生一个微任务(Promise.then是微任务)。</p> <p>也就是说 <code>await 前面的代码</code> 是同步的，调用此函数时会直接执行；</p> <p>而 <code>await func();</code> 这句可以被转换成 <code>Promise.resolve(func())</code> ； <code>await 后面的代码</code> 则会被放到 Promise 的 then() 方法里。</p> <p>但是我们要注意这个微任务产生的时机，它是执行完await之后，直接跳出async函数，执行其他代码(此处就是线程的运作，A暂停执行，控制权交给B)。</p> <p><strong>其他代码执行完毕后，再回到async函数去执行剩下的代码，然后把await后面的代码注册到微任务队列当中。</strong></p> <p>我们来看个例子：</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script start'</span><span class="token punctuation">)</span>

<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">async1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">await</span> <span class="token function">async2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'async1 end'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">async2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'async2 end'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">async1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>

<span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Promise'</span><span class="token punctuation">)</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise1'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise2'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script end'</span><span class="token punctuation">)</span>
<span class="token comment">// 旧版Chrome输出如下，但是请继续看完本文下面的注意那里，新版有改动</span>
<span class="token comment">// script start =&gt; async2 end =&gt; Promise =&gt; script end =&gt; promise1 =&gt; promise2 =&gt; async1 end =&gt; setTimeout</span>
</code></pre></div><p>分析这段代码：</p> <ul><li>执行代码，输出 <code>script start</code> 。</li> <li>执行async1(), 会调用async2(), 然后输出 <code>async2 end</code> , 此时将会保留async1函数的上下文，然后跳出async1函数。</li> <li>遇到setTimeout，产生一个宏任务</li> <li>执行Promise，输出 <code>Promise</code> 。遇到then，产生第一个微任务</li> <li>继续执行代码，输出 <code>script end</code></li> <li>代码逻辑执行完毕(当前宏任务执行完毕)，开始执行当前宏任务产生的微任务队列，输出 <code>promise1</code> ，该微任务遇到then，产生一个新的微任务</li> <li>执行产生的微任务，输出 <code>promise2</code> , 当前微任务队列执行完毕。执行权回到async1</li> <li>执行await, 实际上会产生一个promise返回，即</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> promise_ <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>执行完成，执行await后面的语句，输出 <code>async1 end</code></p> <ul><li>最后，执行下一个宏任务，即执行setTimeout，输出 <code>setTimeout</code></li></ul> <h4 id="注意"><a href="#注意" aria-hidden="true" class="header-anchor">#</a> 注意</h4> <p>新版的chrome浏览器中不是如上打印的，因为chrome优化了, await变得更快了, 输出为:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// script start =&gt; async2 end =&gt; Promise =&gt; script end =&gt; async1 end =&gt; promise1 =&gt; promise2 =&gt; setTimeout</span>
</code></pre></div><p>但是这种做法其实是违法了规范的，当然规范也是可以更改的，这是 V8 团队的一个 <a href="https://github.com/tc39/ecma262/pull/1250#issue-197979338" target="_blank" rel="noopener noreferrer">PR<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> ，目前新版打印已经修改。 知乎上也有相关讨论, 可以看看 <a href="https://www.zhihu.com/question/268007969" target="_blank" rel="noopener noreferrer">www.zhihu.com/question/26…<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>我们可以分2种情况来理解：</p> <ol><li>如果await 后面直接跟的为一个变量，比如：await 1；这种情况的话相当于直接把await后面的代码注册为一个微任务，可以简单理解为promise.then(await下面的代码)。然后跳出async1函数，执行其他代码，当遇到promise函数的时候，会注册promise.then()函数到微任务队列，注意此时微任务队列里面已经存在await后面的微任务。所以这种情况会先执行await后面的代码（async1 end），再执行async1函数后面注册的微任务代码(promise1,promise2)。</li> <li>如果await后面跟的是一个异步函数的调用，比如上面的代码，将代码改成这样：</li></ol> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script start'</span><span class="token punctuation">)</span>

<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">async1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">await</span> <span class="token function">async2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'async1 end'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">async2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'async2 end'</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'async2 end1'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">async1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>

<span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Promise'</span><span class="token punctuation">)</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise1'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise2'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script end'</span><span class="token punctuation">)</span>
</code></pre></div><p>输出为：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// script start =&gt; async2 end =&gt; Promise =&gt; script end =&gt; async2 end1 =&gt; promise1 =&gt; promise2 =&gt; async1 end =&gt; setTimeout</span>
</code></pre></div><p>此时执行完await并不先把await后面的代码注册到微任务队列中去，而是执行完await之后，直接跳出async1函数，执行其他代码。然后遇到promise的时候，把promise.then注册为微任务。其他代码执行完毕后，需要回到async1函数去执行剩下的代码，然后把await后面的代码注册到微任务队列当中，注意此时微任务队列中是有之前注册的微任务的。所以这种情况会先执行async1函数之外的微任务(promise1, promise2)，然后才执行async1内注册的微任务(async1 end). 可以理解为，这种情况下，await 后面的代码会在本轮循环的最后被执行. 浏览器中有事件循环，node 中也有，事件循环是 node 处理非阻塞 I/O 操作的机制，node中事件循环的实现是依靠的libuv引擎。由于 node 11 之后，事件循环的一些原理发生了变化，这里就以新的标准去讲，最后再列上变化点让大家了解前因后果。</p> <h3 id="_4-node-中的事件循环"><a href="#_4-node-中的事件循环" aria-hidden="true" class="header-anchor">#</a> (4)node 中的事件循环</h3> <p>浏览器中有事件循环，node 中也有，事件循环是 node 处理非阻塞 I/O 操作的机制，node中事件循环的实现是依靠的libuv引擎。由于 node 11 之后，事件循环的一些原理发生了变化，这里就以新的标准去讲，最后再列上变化点让大家了解前因后果。</p> <h4 id="宏任务和微任务"><a href="#宏任务和微任务" aria-hidden="true" class="header-anchor">#</a> 宏任务和微任务</h4> <p>node 中也有宏任务和微任务，与浏览器中的事件循环类似，其中，</p> <p>macro-task 大概包括：</p> <ul><li>setTimeout</li> <li>setInterval</li> <li>setImmediate</li> <li>script（整体代码)</li> <li>I/O 操作等。</li></ul> <p>micro-task 大概包括：</p> <ul><li>process.nextTick(与普通微任务有区别，在微任务队列执行之前执行)</li> <li>new Promise().then(回调)等。</li></ul> <h4 id="node事件循环整体理解"><a href="#node事件循环整体理解" aria-hidden="true" class="header-anchor">#</a> node事件循环整体理解</h4> <p>先看一张官网的 node 事件循环简化图：</p> <p><img src="/assets/img/node-eventloop.54cca9eb.png" alt="node-eventloop.png"></p> <p>图中的每个框被称为事件循环机制的一个阶段，每个阶段都有一个 FIFO 队列来执行回调。虽然每个阶段都是特殊的，但通常情况下，当事件循环进入给定的阶段时，它将执行特定于该阶段的任何操作，然后执行该阶段队列中的回调，直到队列用尽或最大回调数已执行。当该队列已用尽或达到回调限制，事件循环将移动到下一阶段。</p> <p>因此，从上面这个简化图中，我们可以分析出 node 的事件循环的阶段顺序为：</p> <p>输入数据阶段(incoming data)-&gt;轮询阶段(poll)-&gt;检查阶段(check)-&gt;关闭事件回调阶段(close callback)-&gt;定时器检测阶段(timers)-&gt;I/O事件回调阶段(I/O callbacks)-&gt;闲置阶段(idle, prepare)-&gt;轮询阶段...</p> <h4 id="阶段概述"><a href="#阶段概述" aria-hidden="true" class="header-anchor">#</a> 阶段概述</h4> <ul><li>定时器检测阶段(timers)：本阶段执行 timer 的回调，即 setTimeout、setInterval 里面的回调函数。</li> <li>I/O事件回调阶段(I/O callbacks)：执行延迟到下一个循环迭代的 I/O 回调，即上一轮循环中未被执行的一些I/O回调。</li> <li>闲置阶段(idle, prepare)：此阶段&quot;仅供内部使用&quot;。</li> <li>轮询阶段(poll)：检索新的 I/O 事件; 执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和 setImmediate() 调度的之外），其余情况 node 将在适当的时候在此阻塞。</li> <li>检查阶段(check)：setImmediate() 回调函数在这里执行</li> <li>关闭事件回调阶段(close callback)：一些关闭的回调函数，如：执行 socket 的 close 事件回调socket.on('close', ... )。</li></ul> <h4 id="三大重点阶段"><a href="#三大重点阶段" aria-hidden="true" class="header-anchor">#</a> 三大重点阶段</h4> <p>与我们开发相关的三个阶段分别是 <code>poll</code> 、 <code>check</code> 、 <code>timers</code> ，日常开发中的绝大部分异步任务都是在 <code>poll</code> 、 <code>check</code> 、 <code>timers</code> 这3个阶段处理的, 所以我们来重点看看。</p> <h5 id="timers"><a href="#timers" aria-hidden="true" class="header-anchor">#</a> timers</h5> <p>timers 阶段会执行 setTimeout 和 setInterval 回调，并且是由 poll 阶段控制的。 同样，在 Node 中定时器指定的时间也不是准确时间，只能是尽快执行。</p> <h5 id="poll"><a href="#poll" aria-hidden="true" class="header-anchor">#</a> poll</h5> <p>poll 是一个至关重要的阶段，poll 阶段的执行逻辑流程图如下：</p> <p><img src="/assets/img/poll-logic-flowchart.01cc82e8.png" alt=""></p> <p>如果当前已经存在定时器，而且有定时器到时间了，拿出来执行，eventLoop 将回到 timers 阶段。</p> <p>如果没有定时器, 会去看回调函数队列。</p> <ul><li>如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制</li> <li>如果 poll 队列为空时，会有两件事发生
<ul><li>如果有 setImmediate 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调</li> <li>如果没有 setImmediate 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去, 一段时间后自动进入 check 阶段。</li></ul></li></ul> <h5 id="check"><a href="#check" aria-hidden="true" class="header-anchor">#</a> check</h5> <p>check 阶段。这是一个比较简单的阶段，直接执行 setImmdiate 的回调。</p> <h4 id="process-nexttick"><a href="#process-nexttick" aria-hidden="true" class="header-anchor">#</a> process.nextTick</h4> <p>process.nextTick 是一个独立于 eventLoop 的任务队列。</p> <p>在每一个 eventLoop 阶段完成后会去检查 nextTick 队列，如果里面有任务，会让这部分任务优先于微任务执行。</p> <p>看一个例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timeout1'</span><span class="token punctuation">)</span>
    Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise resolve'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'next tick1'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timeout2'</span><span class="token punctuation">)</span>
    process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'next tick2'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timeout3'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timeout4'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>在 node11 之前，因为每一个 eventLoop 阶段完成后会去检查 nextTick 队列，如果里面有任务，会让这部分任务优先于微任务执行，因此上述代码是先进入 check 阶段，执行所有 setImmediate，完成之后执行 nextTick 队列，最后执行微任务队列，因此输出为 <code>timeout1=&gt;timeout2=&gt;timeout3=&gt;timeout4=&gt;next tick1=&gt;next tick2=&gt;promise resolve</code></li> <li>在 node11 之后，process.nextTick 是微任务的一种, 因此上述代码是先进入 check 阶段，执行一个 setImmediate 宏任务，然后执行其微任务队列，再执行下一个宏任务及其微任务, 因此输出为 <code>timeout1=&gt;next tick1=&gt;promise resolve=&gt;timeout2=&gt;next tick2=&gt;timeout3=&gt;timeout4</code></li></ul> <h3 id="node-版本差异说明"><a href="#node-版本差异说明" aria-hidden="true" class="header-anchor">#</a> node 版本差异说明</h3> <p>这里主要说明的是 node11 前后的差异，因为 node11 之后一些特性已经向浏览器看齐了。</p> <p>总的变化一句话来说就是，</p> <p><strong>如果是 node11 版本一旦执行一个阶段里的一个宏任务(setTimeout, setInterval和setImmediate)就立刻执行对应的微任务队列，而不是在微任务队列中注册完就先不管了</strong></p> <h4 id="timers-阶段的执行时机变化"><a href="#timers-阶段的执行时机变化" aria-hidden="true" class="header-anchor">#</a> timers 阶段的执行时机变化</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timer1'</span><span class="token punctuation">)</span>
    Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise1'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timer2'</span><span class="token punctuation">)</span>
    Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise2'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>如果是 node11 版本<strong>一旦执行一个阶段里的一个宏任务(setTimeout, setInterval和setImmediate)就立刻执行微任务队列</strong>，这就跟浏览器端运行一致，最后的结果为 <code>timer1=&gt;promise1=&gt;timer2=&gt;promise2</code></li> <li>如果是 node10 及其之前版本要看第一个定时器执行完，第二个定时器是否在完成队列中.
<ul><li>如果是第二个定时器还未在完成队列中，最后的结果为 <code>timer1=&gt;promise1=&gt;timer2=&gt;promise2</code></li> <li>如果是第二个定时器已经在完成队列中，则最后的结果为 <code>timer1=&gt;timer2=&gt;promise1=&gt;promise2</code></li></ul></li></ul> <h4 id="check-阶段的执行时机变化"><a href="#check-阶段的执行时机变化" aria-hidden="true" class="header-anchor">#</a> check 阶段的执行时机变化</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'immediate1'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'immediate2'</span><span class="token punctuation">)</span>
    Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise resolve'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'immediate3'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'immediate4'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>如果是 node11 后的版本，会输出 <code>immediate1=&gt;immediate2=&gt;promise resolve=&gt;immediate3=&gt;immediate4</code></li> <li>如果是 node11 前的版本，会输出 <code>immediate1=&gt;immediate2=&gt;immediate3=&gt;immediate4=&gt;promise resolve</code></li></ul> <h4 id="nexttick-队列的执行时机变化"><a href="#nexttick-队列的执行时机变化" aria-hidden="true" class="header-anchor">#</a> nextTick 队列的执行时机变化</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timeout1'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timeout2'</span><span class="token punctuation">)</span>
    process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'next tick'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timeout3'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timeout4'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>如果是 node11 后的版本，会输出 <code>timeout1=&gt;timeout2=&gt;next tick=&gt;timeout3=&gt;timeout4</code></li> <li>如果是 node11 前的版本，会输出 <code>timeout1=&gt;timeout2=&gt;timeout3=&gt;timeout4=&gt;next tick</code></li></ul> <p>以上几个例子，你应该就能清晰感受到它的变化了，反正记着一个结论，如果是 node11 版本一旦执行一个阶段里的一个宏任务(setTimeout, setInterval和setImmediate)就立刻执行对应的微任务队列。</p> <h3 id="node-和-浏览器-eventloop的主要区别"><a href="#node-和-浏览器-eventloop的主要区别" aria-hidden="true" class="header-anchor">#</a> node 和 浏览器 eventLoop的主要区别</h3> <p>两者最主要的区别在于浏览器中的微任务是在每个相应的宏任务中执行的，而nodejs中的微任务是在不同阶段之间执行的。</p> <blockquote><p>本文部分来自</p> <p>https://juejin.im/post/5e5c7f6c518825491b11ce93</p> <p>https://juejin.im/post/5cbc0a9cf265da03b11f3505#heading-14</p></blockquote></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">最后更新时间: </span> <span class="time">6/10/2020, 4:44:37 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/network-tcp/015-conclusion/" class="prev">
          014-总结
        </a></span> <span class="next"><a href="/interview/002-closure/">
          002: 闭包
        </a>
        →
      </span></p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.b1906b97.js" defer></script><script src="/assets/js/2.bdee5faf.js" defer></script><script src="/assets/js/5.06355c1f.js" defer></script><script src="/assets/js/7.f0379e88.js" defer></script><script src="/assets/js/8.e132ed9d.js" defer></script>
  </body>
</html>
